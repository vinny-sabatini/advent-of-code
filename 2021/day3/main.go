package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
)

// Day 3 challenge 1 takes in an input file of many lines of binary numbers
// The "gamma rate" is generated by the most common bits at each location
// The "epsilon rate" is generated by the least common bits at each location
// The "power consumption" is generated by multiplying gamma rate by epsilon rate
// Using `small-input.txt`, gamma rate = 10110 (22), episilon rate = 01001 (9), total = 198.
//
// Day 3 challenge 2 takes in an input file of many lines of binary numbers
// The "oxygen generator rate" is found by:
// - Retriving the most common bit in the first position
// - Keeping only the entries with that most common bit
// - Continue until you only have one entry
// The "CO2 rate" is found by doing the same thing with the least common bit
// The "life support rating" is found by multiplying the CO2 by the O2 rating
// Using `small-imput.txt`, oxygen = 10111 (23), CO2 = 01010 (10), life support = 230
func main() {
	input, err := os.Open("./input.txt")
	if err != nil {
		fmt.Println("Failed to open input.txt", err)
		os.Exit(1)
	}
	defer input.Close()

	scanner := bufio.NewScanner(input)

	var tracker []string

	for scanner.Scan() {
		tracker = append(tracker, scanner.Text())
	}

	o2, _ := strconv.ParseInt(o2rating(tracker, 0)[0], 2, 64)
	co2, _ := strconv.ParseInt(co2rating(tracker, 0)[0], 2, 64)
	total := o2 * co2
	fmt.Printf("O2 = %v, CO2 = %v, Life = %v\n", o2, co2, total)
}

func o2rating(input []string, position int) []string {
	var result []string
	commonBit := 0
	for _, v := range input {
		current := v[position]
		if current == 48 {
			commonBit = commonBit - 1
		} else {
			commonBit = commonBit + 1
		}
	}

	for _, v := range input {
		current := v[position]
		if current == 48 && commonBit < 0 {
			result = append(result, v)
		}
		if current == 49 && commonBit >= 0 {
			result = append(result, v)
		}
	}

	if len(result) != 1 {
		return o2rating(result, position+1)
	}

	return result
}

func co2rating(input []string, position int) []string {
	var result []string
	commonBit := 0
	for _, v := range input {
		current := v[position]
		if current == 48 {
			commonBit = commonBit + 1
		} else {
			commonBit = commonBit - 1
		}
	}

	for _, v := range input {
		current := v[position]
		if current == 48 && commonBit <= 0 {
			result = append(result, v)
		}
		if current == 49 && commonBit > 0 {
			result = append(result, v)
		}
	}

	if len(result) != 1 {
		return co2rating(result, position+1)
	}

	return result
}
